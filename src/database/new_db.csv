original_text,summary
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","What is the purpose of the `filter_map` method in Rust?
The `filter_map` method in Rust is a combination of the `filter` and `map` methods. It applies a closure to each element of an iterator, but only includes the results that are not `None`.

In other words, it filters out the elements for which the closure returns `None`, while still applying the closure to all elements.

The general syntax of `filter_map` is:
```rust
iter.filter_map(|element| {
    // closure that may return Some(value) or None
})
```
Here's an example:
```rust
let numbers = vec![1, 2, 3, 4, 5];
let even_numbers: Vec<_> = numbers.into_iter().filter_map(|n| if n % 2 == 0 { Some(n) } else { None }).collect();
println!(""{:?}"", even_numbers); // prints [2, 4]
```
In this example, the closure returns `Some(n)` only when `n` is even, and `None` otherwise. The `filter_map` method then filters out the elements for which the closure returned `None`, resulting in a vector of only the even numbers.

The purpose of `filter_map` is to simplify code that would otherwise require using both `map` and `filter` methods together. It's a convenient way to transform an iterator while filtering out unwanted results."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","How does the `map_err` function work with `Result` and `Option` types?
`map_err` is a method that can be called on `Result` and `Option` types in Rust. It's used to transform the error value associated with these types.

**For `Result`:**

When you call `map_err` on a `Result`, it takes a closure as an argument, which will be applied to the error value if the result is `Err`. The resulting error value can then be transformed into another type of error. Here's an example:

```rust
fn main() {
    let result = Err(""Something went wrong"".to_string());
    let new_error = result.map_err(|e| e.to_uppercase());
    println!(""{:?}"", new_error); // prints ""SOMETHING WENT WRONG""
}
```

In this example, the `map_err` method takes a closure that converts the error string to uppercase. The resulting error value is then returned by `map_err`.

**For `Option`:**

When you call `map_err` on an `Option`, it's equivalent to calling `map` and then `unwrap_or_else`. This means that if the option is `Some`, the closure will be applied to its value, but if the option is `None`, the closure will not be called.

```rust
fn main() {
    let option = Some(""Hello"".to_string());
    let new_value = option.map_err(|e| e.to_uppercase());
    println!(""{:?}"", new_value); // prints ""SOME"" (not ""HELLO"")
}
```

In this example, the `map_err` method takes a closure that converts the value to uppercase. However, since the option is `Some`, the closure will be applied to its value, resulting in an error.

**Common use cases:**

1. **Error handling:** When working with `Result` or `Option`, you can use `map_err` to transform errors into a more specific type of error.
2. **Logging:** You can use `map_err` to log the original error message before transforming it into another type of error.
3. **Error wrapping:** You can use `map_err` to wrap an error in a custom error type, making it easier to handle and propagate errors throughout your codebase.

In summary, `map_err` is a powerful method that allows you to transform the error value associated with `Result` and `Option` types in Rust. It's commonly used for error handling, logging, and error wrapping."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","Can you collect all failed items from a sequence of results using a single method call?
Yes, you can collect all failed items from a sequence of results using the `filter_map` method in combination with `map_err`. 

Here's an example:

```rust
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let errors: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| Some(e)).ok())
        .collect();
    println!(""Errors: {:?}"", errors);
}
```

In this example, `filter_map` is used to filter out the successful results and collect only the failed ones. The `map_err` method is used to transform each error into a value that can be collected by `filter_map`."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","What happens when you use `collect` on a sequence of results that contains an error?
When you use `collect` on a sequence of results that contains an error, the iteration will terminate as soon as it encounters the first error. This is because `Result` implements `FromIterator`, and when collecting a vector of results into a single result, if any element in the vector is an error, the entire collection becomes an error.

In other words, once an error occurs during the iteration, the remaining elements are not processed, and the function returns immediately with the first encountered error. This behavior is often referred to as ""short-circuiting"" or ""early termination"".

Here's a code example that demonstrates this:
```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    
    match numbers {
        Ok(numbers) => println!(""Numbers: {:?}"", numbers),
        Err(e) => println!(""Error: {}"", e),
    }
}
```
In this example, if the first string ""tofu"" cannot be parsed into an `i32`, the iteration will terminate immediately, and the function will return with the error message. The remaining strings (""93"" and ""18"") are not processed.

This behavior is useful when you want to handle errors as soon as they occur, rather than waiting for all elements in a sequence to be processed."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","How can you partition a sequence of results into two separate sequences, one for valid values and one for failures?
You can partition a sequence of results into two separate sequences, one for valid values and one for failures, using the `partition` method in Rust.

Here's an example:
```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
In this example, `Result::is_ok` is a closure that takes a `Result` and returns `true` if it's an `Ok` value (i.e., the result was successful) and `false` otherwise. The `partition` method splits the sequence of results into two separate sequences: one for the values where `Result::is_ok` returned `true`, and another for the values where `Result::is_ok` returned `false`.

The resulting tuples contain two vectors: `numbers` contains all the successful results, and `errors` contains all the failed results.

Note that this approach requires unwrapping the results to get the actual values. You can do this using the `into_iter` method followed by a call to `Result::unwrap` or `Result::unwrap_err`, like this:
```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
This will print the actual values in the `numbers` vector and the error messages in the `errors` vector."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","Why is it necessary to unwrap the results in the `partition` example?
In the `partition` example, we use `Result::is_ok` to partition the results into two vectors: one for successful parses (`numbers`) and one for errors (`errors`). However, this method returns a tuple of two iterators, where each iterator contains the corresponding elements from the original vector.

The problem is that these iterators still contain `Result`s, not the actual values or error messages. To get the actual values or error messages, we need to unwrap them using `Result::unwrap` for successful parses and `Result::unwrap_err` for errors.

If we didn't unwrap the results, we would end up with vectors of `Result`s instead of the actual values or error messages. For example:

```rust
let (numbers, errors): (Vec<_>, Vec<_>) = strings
    .into_iter()
    .map(|s| s.parse::<i32>())
    .partition(Result::is_ok);
```

In this case, `numbers` and `errors` would be vectors of `Result`s, like this:

```rust
let numbers: Vec<_> = vec![Ok(93), Ok(18)];
let errors: Vec<_> = vec![Err(""tofu"".parse::<i32>().unwrap_err())];
```

To get the actual values or error messages, we need to unwrap these `Result`s using `Result::unwrap` for successful parses and `Result::unwrap_err` for errors.

```rust
let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
```

This would give us the final result:

```rust
let numbers: Vec<_> = vec![93, 18];
let errors: Vec<_> = vec![""tofu"".parse::<i32>().unwrap_err()];
```"
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","Can you collect all valid values from a sequence of results using a single method call?
Yes, you can collect all valid values from a sequence of results using the `filter_map` method in combination with the `ok` method. 

Here's an example:

```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .filter_map(|r| r.ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```

In this example, `ok` is a method on the `Result` type that returns `Some(value)` if the result is `Ok`, and `None` otherwise. The `filter_map` method applies this to each element in the sequence of results, effectively filtering out any `Err` values and collecting only the valid ones into a new vector."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","What is the difference between `Result::is_ok` and `Result::unwrap` methods?
`Result::is_ok` and `Result::unwrap` are two different methods in Rust that serve distinct purposes.

**`Result::is_ok`**

`Result::is_ok` is a method that takes a `Result<T, E>` as an argument and returns a boolean value indicating whether the result is `Ok(T)` or not. It does not consume the result, meaning it doesn't unwrap or extract any values from it.

Here's an example:
```rust
let result = Ok(5);
println!(""{}"", Result::is_ok(&result)); // prints: true

let error_result = Err(""some error"");
println!(""{}"", Result::is_ok(&error_result)); // prints: false
```
**`Result::unwrap`**

`Result::unwrap`, on the other hand, is a method that takes a `Result<T, E>` as an argument and returns the value inside it if it's `Ok(T)`. If the result is `Err(E)`, it will panic with the error message.

Here's an example:
```rust
let result = Ok(5);
println!(""{}"", result.unwrap()); // prints: 5

let error_result = Err(""some error"");
result.unwrap(); // panics with ""some error""
```
In summary:

* `Result::is_ok` checks if a result is `Ok(T)` without consuming it.
* `Result::unwrap` extracts the value from a result if it's `Ok(T)`, but panics if it's `Err(E)`.

When to use each method?

* Use `Result::is_ok` when you need to check if a result is valid without modifying or consuming it.
* Use `Result::unwrap` when you're sure that the result will always be `Ok(T)` and you want to extract its value. However, be aware of the potential for panicking if the result is actually `Err(E)`."
"Iterating over Results
An Iter::map operation might fail, for example:
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Let's step through strategies for handling this.
Ignore the failed items with filter_map()
filter_map calls a function and filters out the results that are None.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
Collect the failed items with map_err() and filter_map()
map_err calls a function with the error, so by adding that to the previous filter_map solution we can save them off to the side while iterating.
```
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
Fail the entire operation with collect()
Result implements FromIterator so that a vector of results (Vec<Result<T, E>>) can be turned into a result with a vector (Result<Vec<T>, E>). Once an Result::Err is found, the iteration will terminate.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```
This same technique can be used with Option.
Collect all valid values and failures with partition()
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```
When you look at the results, you'll note that everything is still wrapped in Result. A little more boilerplate is needed for this.
```
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```","How can you handle errors that occur during iteration over a sequence of results?
There are several strategies to handle errors that occur during iteration over a sequence of results in Rust:

1. **Ignore the failed items with `filter_map()`**: You can use `filter_map` to call a function and filter out the results that are `None`. This approach discards any errors that occur during iteration.

   ```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```

2. **Collect the failed items with `map_err()` and `filter_map()`**: You can use `map_err` to call a function with the error, so by adding that to the previous `filter_map` solution you can save them off to the side while iterating.

   ```rust
fn main() {
    let strings = vec![""42"", ""tofu"", ""93"", ""999"", ""18""];
    let mut errors = vec![];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<u8>())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```

3. **Fail the entire operation with `collect()`**: You can use `Result::FromIterator` to turn a vector of results into a result with a vector. Once an `Result::Err` is found, the iteration will terminate.

   ```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let numbers: Result<Vec<_>, _> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!(""Results: {:?}"", numbers);
}
```

4. **Collect all valid values and failures with `partition()`**: You can use `Result::is_ok` to partition the results into two vectors, one for successful parses and one for errors.

   ```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```

5. **Collect all valid values and failures with `partition()` and unwrap**: You can use `Result::unwrap` to unwrap the successful parses and `Result::unwrap_err` to unwrap the errors.

   ```rust
fn main() {
    let strings = vec![""tofu"", ""93"", ""18""];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);
    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!(""Numbers: {:?}"", numbers);
    println!(""Errors: {:?}"", errors);
}
```"
"Pulling Results out of Options
The most basic way of handling mixed error types is to just embed them in each other.
```
use std::num::ParseIntError;
fn double_first(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {
    vec.first().map(|first| {
        first.parse::<i32>().map(|n| 2 * n)
    })
}
fn main() {
    let numbers = vec![""42"", ""93"", ""18""];
    let empty = vec![];
    let strings = vec![""tofu"", ""93"", ""18""];
    println!(""The first doubled is {:?}"", double_first(numbers));
    println!(""The first doubled is {:?}"", double_first(empty));
    // Error 1: the input vector is empty
    println!(""The first doubled is {:?}"", double_first(strings));
    // Error 2: the element doesn't parse to a number
}
```
There are times when we'll want to stop processing on errors (like with ?) but keep going when the Option is None. A couple of combinators come in handy to swap the Result and Option.
```
use std::num::ParseIntError;
fn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
    let opt = vec.first().map(|first| {
        first.parse::<i32>().map(|n| 2 * n)
    });
    opt.map_or(Ok(None), |r| r.map(Some))
}
fn main() {
    let numbers = vec![""42"", ""93"", ""18""];
    let empty = vec![];
    let strings = vec![""tofu"", ""93"", ""18""];
    println!(""The first doubled is {:?}"", double_first(numbers));
    println!(""The first doubled is {:?}"", double_first(empty));
    println!(""The first doubled is {:?}"", double_first(strings));
}
```","**Summary: Handling Mixed Error Types with Options and Results**

In this example, we're dealing with mixed error types using the `Option` and `Result` types in Rust. The goal is to handle errors and edge cases when working with data that may be invalid or missing.

**Concepts Covered:**

1. **Embedding Errors**: We start by embedding errors into each other, where a `Result` type contains an error of another type (`ParseIntError`). This allows us to propagate errors up the call stack.
2. **Swapping Result and Option**: When we want to stop processing on errors but keep going when the `Option` is `None`, we use combinators to swap the `Result` and `Option`. Specifically, we use `map_or` to transform the `Result` into an `Option`.

**Techniques Used:**

1. **Using `first()`**: We use the `first()` method on a vector to get the first element, which is then used for parsing.
2. **Parsing with `parse()`**: We use the `parse()` method to convert a string into an integer (`i32`).
3. **Error Handling with `map()` and `map_or()`**: We use `map()` to transform the result of parsing into a doubled value, and `map_or()` to handle the case where the vector is empty.
4. **Swapping Result and Option**: We use `map_or` to swap the `Result` and `Option`, allowing us to keep going when the `Option` is `None`.

**Conclusions:**

1. **Error Handling is Crucial**: When working with data that may be invalid or missing, error handling is essential to prevent crashes and unexpected behavior.
2. **Using Combinators can Simplify Code**: By using combinators like `map_or`, we can simplify our code and make it more readable.
3. **Rust's Type System helps with Error Handling**: Rust's type system enforces strong error handling practices, making it easier to write robust and reliable code.

Overall, this example demonstrates how to handle mixed error types in Rust using `Option` and `Result`, and highlights the importance of error handling in programming."
